package lyc.compiler;

import java_cup.runtime.*;
import java.util.Stack;
import lyc.compiler.files.SymbolTableGenerator;
import lyc.compiler.files.IntermediateCodeGenerator;
import lyc.compiler.files.TripleManager;

class Parser;

action code {:
  private Stack<Integer> jumpStack = new Stack<>();
:}

// Terminals

terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;

terminal EQUAL;
terminal NOT_EQUAL;
terminal LESS_EQUAL;
terminal GREATER_EQUAL;
terminal LESS;
terminal GREATER;

terminal ASSIG;

terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;

terminal OPEN_CURLY_BRACKET;
terminal CLOSE_CURLY_BRACKET;

terminal OPEN_SQUARE_BRACKET;
terminal CLOSE_SQUARE_BRACKET;

terminal COMMA;
terminal COLON;

terminal WHILE;
terminal IF;
terminal ELSE;
terminal INIT;
terminal TYPE_INT;
terminal TYPE_FLOAT;
terminal TYPE_STRING;

terminal READ;
terminal WRITE;

terminal AND;
terminal OR;
terminal NOT;

terminal REORDER_FUNCTION;
terminal NEGATIVE_CALCULATION_FUNCTION;

terminal String INTEGER_CONSTANT;
terminal String FLOAT_CONSTANT;
terminal String STRING_CONSTANT;
terminal String IDENTIFIER;

// Non Terminals
non terminal start_symbol;
non terminal program;
non terminal var_declaration;
non terminal iteration;
non terminal selection;
non terminal sentence;
non terminal assignment;

non terminal String expression;
non terminal String term;
non terminal String factor;
non terminal String constant;

non terminal String condition;
non terminal String comparation;
non terminal String comparator;

non terminal list_declaration;
non terminal var_list;
non terminal var_type;
non terminal function;
non terminal negative_function;
non terminal reorder_function;
non terminal arguments;
non terminal arguments_list;
non terminal float_list;
non terminal float_element;
non terminal write_args;

// Start Symbol Definition
start with start_symbol;

// Rules
start_symbol        ::= program
                        {:
                            System.out.println("End");
                        :}
                        ;

program             ::= program sentence {: System.out.println("program = program sentence"); :} |
                        sentence {: System.out.println("program = sentence"); :}
                        ;

sentence            ::= assignment {: System.out.println("sentence = assignment"); :} |
                        var_declaration {: System.out.println("sentence = var_declaration"); :} |
                        iteration {: System.out.println("sentence = iteration"); :} |
                        selection {: System.out.println("sentence = selection"); :} |
                        function {: System.out.println("sentence = function"); :}
                        ;

assignment          ::= IDENTIFIER:id ASSIG expression:e
                        {:
                            TripleManager.addTriple(":=", id, "[" + e + "]");
                            System.out.println("assignment = id=expression");
                        :} |
                        IDENTIFIER:id ASSIG negative_function:nf
                        {:
                            TripleManager.addTriple(":=", id, "[" + nf + "]");
                            System.out.println("assignment = id=negative_function");
                        :} |
                        IDENTIFIER:id ASSIG STRING_CONSTANT:sc
                        {:
                            TripleManager.addTriple(":=", id, sc);
                            System.out.println("assignment = id=string_constant");
                        :}
                        ;

selection           ::= IF OPEN_BRACKET condition CLOSE_BRACKET OPEN_CURLY_BRACKET program CLOSE_CURLY_BRACKET
                        {:
                            // Desapilamos el caso falso de la condición para saltar al final
                            int falseIdx = jumpStack.pop();
                            TripleManager.patchTriple(falseIdx, TripleManager.getLastIndex() + 1);

                            System.out.println("selection = if (condition) { program }");
                        :} |
                        IF OPEN_BRACKET condition CLOSE_BRACKET OPEN_CURLY_BRACKET program CLOSE_CURLY_BRACKET
                        {:
                            // Desapilamos el caso falso de la condición para saltar al else
                            int falseIdx = jumpStack.pop();
                            TripleManager.patchTriple(falseIdx, TripleManager.getLastIndex() + 2);

                            // Si fue verdadero nos saltamos el else
                            int biIdx = TripleManager.addTriple("BI", "J", null);
                            jumpStack.push(biIdx);
                        :}
                        ELSE OPEN_CURLY_BRACKET program CLOSE_CURLY_BRACKET
                        {:
                            // Si fue verdadero nos saltamos el else
                            int biIdx = jumpStack.pop();

                            TripleManager.patchTriple(biIdx, TripleManager.getLastIndex() + 1);
                            System.out.println("selection = if (condition) { program } else { program }");
                        :}
                        ;

iteration           ::= WHILE OPEN_BRACKET {:
                            // Para volver al principio a iterar
                            int etIdx = TripleManager.addTriple("ET", "WHILE", null);
                            jumpStack.push(etIdx);
                        :}
                        condition CLOSE_BRACKET OPEN_CURLY_BRACKET program CLOSE_CURLY_BRACKET
                        {:
                            // Desapilamos el caso falso de la condición para salir del while
                            int falseIdx = jumpStack.pop();
                            TripleManager.patchTriple(falseIdx, TripleManager.getLastIndex() + 2);

                            // Bifurcación para volver a evaluar la condición
                            int etIdx = jumpStack.pop();
                            int biIdx = TripleManager.addTriple("BI", "[" + etIdx + "]", null);

                            System.out.println("while (condition) { program }");
                        :};

var_declaration     ::= INIT OPEN_CURLY_BRACKET list_declaration CLOSE_CURLY_BRACKET {: System.out.println("init { list_declaration }"); :};

list_declaration    ::= list_declaration var_list COLON var_type {: System.out.println("list_declaration = list_declaration var_list : var_type"); :} |
                        var_list COLON var_type {: System.out.println("list_declaration = var_list : var_type"); :}
                        ;

var_list            ::= var_list COMMA IDENTIFIER:id
                        {:System.out.println("var_list = var_list , IDENTIFIER");:} |
                        IDENTIFIER:id
                        {:System.out.println("var_list = IDENTIFIER");:}
                        ;

var_type            ::= TYPE_INT {: System.out.println("int"); :} |
                        TYPE_FLOAT {: System.out.println("float"); :} |
                        TYPE_STRING {: System.out.println("string"); :}
                        ;

expression          ::= expression:e PLUS term:t
                        {:
                            int index = TripleManager.addTriple("+", "[" + e + "]", "[" + t + "]");
                            RESULT = Integer.toString(index);
                            System.out.println("+");
                        :} |
                        expression:e SUB term:t
                        {:
                            int index = TripleManager.addTriple("-", "[" + e + "]", "[" + t + "]");
                            RESULT = Integer.toString(index);
                            System.out.println("-");
                        :} |
                        term:t
                        {:
                            RESULT = t;
                            System.out.println("Expression = Term");
                        :}
                        ;

term                ::= term:t MULT factor:f
                        {:
                            int index = TripleManager.addTriple("*", "[" + t + "]", "[" + f + "]");
                            RESULT = Integer.toString(index);
                            System.out.println("*");
                        :} |
                        term:t DIV factor:f
                        {:
                            int index = TripleManager.addTriple("/", "[" + t + "]", "[" + f + "]");
                            RESULT = Integer.toString(index);
                            System.out.println("/");
                        :} |
                        factor:f
                        {:
                            RESULT = f;
                            System.out.println("Term = factor");
                        :}
                        ;

factor              ::= IDENTIFIER:id
                        {:
                            int index = TripleManager.addTriple(id, null, null);
                            RESULT = Integer.toString(index);
                            System.out.println("Id: " + id);
                        :} |
                        SUB IDENTIFIER:id
                        {:
                            int index = TripleManager.addTriple("-", id, null);
                            RESULT = Integer.toString(index);
                            System.out.println("Negated Id: " + id);
                        :} |
                        constant:cte
                        {:
                            int index = TripleManager.addTriple(cte, null, null);
                            RESULT = Integer.toString(index);
                            System.out.println("Constant: " + cte);
                        :} |
                        SUB constant:cte
                        {:
                            int index = TripleManager.addTriple("-", cte, null);
                            RESULT = Integer.toString(index);
                            System.out.println("Negated Constant: " + cte);
                        :} |
                        OPEN_BRACKET expression:e CLOSE_BRACKET
                        {:
                            RESULT = e;
                            System.out.println("Factor = (Expression)");
                        :}
                        ;

constant            ::= INTEGER_CONSTANT:i
                        {:
                            RESULT = i;
                        :} |
                        FLOAT_CONSTANT:f
                        {:
                            RESULT = f;
                        :}
                        ;

// cuando se pase por esta regla, siempre se saldrá de acá con un sólo índice apilado, el que corresponda al salto por falso
// Puse J por Jump donde iría el salto
condition           ::= comparation:c
                        {:
                            int falseIdx = TripleManager.addTriple(c, "J", null);
                            // Se apila para hacer el salto por caso falso
                            jumpStack.push(falseIdx);

                            System.out.println("condition = comparation");
                        :}
                        |
                        comparation:c1
                        {:
                            int falseIdx1 = TripleManager.addTriple(c1, "J", null);

                            int trueIdx1 = TripleManager.addTriple("BI", "J", null);
                            // Si fue verdadera se apila para despues saltar a la parte verdadera
                            jumpStack.push(trueIdx1);

                            int etIdx = TripleManager.addTriple("ET", "OR", null); // es solo la etiqueta, no se si va

                            // Si la primera comparacion fue falsa, hace un pequeño salto sobre el BI por verdadera
                            TripleManager.patchTriple(falseIdx1, etIdx + 1);
                        :}
                        OR comparation:c2
                        {:
                            // Desapilamos ese idx de recien para hacer el salto por verdadera
                            int trueIdx1 = jumpStack.pop();

                            int falseIdx2 = TripleManager.addTriple(c2, "J", null);
                            // Se apila para hacer el salto por caso falso, porque ambas dieron falsas
                            jumpStack.push(falseIdx2);

                            // Ahora sí hacemos el salto si la primera fue verdadera
                            TripleManager.patchTriple(trueIdx1, falseIdx2 + 1);

                            System.out.println("condition = comparation OR comparation");
                        :}
                        |
                        comparation:c1
                        {:
                            int falseIdx1 = TripleManager.addTriple(c1, "J", null);
                            // Si la primera ya es falsa, va a salir por falso
                            jumpStack.push(falseIdx1);

                            int etIdx = TripleManager.addTriple("ET", "AND", null); // es solo la etiqueta, no se si va
                        :}
                        AND comparation:c2
                        {:
                            int falseIdx2 = TripleManager.addTriple(c2, "J", null);
                            // Si la segunda es falsa, tambien va a salir por falso

                            int trueIdx = TripleManager.addTriple("BI", "J", null);
                            // Si ambas son verdaderas, quiero hacer un pequeño salto sobre los tercetos que vienen ahora (hacia index5 + 1)

                            // Ambos indices del salto por falso saltan a la misma lazy
                            int lazyIdx = TripleManager.addTriple("ET", "LAZY_AND", null);
                            TripleManager.patchTriple(falseIdx2, lazyIdx);
                            int falseIdx1 = jumpStack.pop();
                            TripleManager.patchTriple(falseIdx1, lazyIdx);

                            // Despues de que los dos falsos salten a la lazy, se apila la bifurcacion por falso
                            int biIdx = TripleManager.addTriple("BI", "J", null);
                            jumpStack.push(biIdx);

                            // Hago ese saltito
                            TripleManager.patchTriple(trueIdx, biIdx + 1);
                            System.out.println("condition = comparation AND comparation");
                        :}
                        |
                        NOT comparation:c
                        {:
                            int falseIdx = TripleManager.addTriple(c, "J", null);

                            // Bifurcación para salir por caso falso (o sea verdadero)
                            int trueIdx = TripleManager.addTriple("BI", "J", null);
                            jumpStack.push(trueIdx);

                            // Si fue verdadero (o sea falso) hace un saltito sobre la bifurcación
                            TripleManager.patchTriple(falseIdx,trueIdx + 1);

                            int etIdx = TripleManager.addTriple("ET", "NOT", null); // es solo la etiqueta, no se si va

                            System.out.println("condition = NOT comparation");
                        :};

comparation         ::= expression:e1 comparator:c expression:e2
                        {:
                            TripleManager.addTriple("CMP", "[" + e1 + "]", "[" + e2 + "]");
                            RESULT = c;
                            System.out.println("comparation = expression comparator expression");
                        :};

comparator          ::= EQUAL
                        {:
                            RESULT = "BNE";
                            System.out.println("==");
                        :}|
                        NOT_EQUAL
                        {:
                            RESULT = "BEQ";
                            System.out.println("!=");
                        :} |
                        LESS_EQUAL
                        {:
                            RESULT = "BGT";
                            System.out.println("<=");
                        :} |
                        GREATER_EQUAL
                        {:
                            RESULT = "BLT";
                            System.out.println(">=");
                        :} |
                        LESS
                        {:
                            RESULT = "BGE";
                            System.out.println("<");
                        :} |
                        GREATER
                        {:
                            RESULT = "BLE";
                            System.out.println(">");
                        :}
                        ;

function            ::= reorder_function  {: System.out.println("function = reorder_function"); :} |
                        READ OPEN_BRACKET IDENTIFIER CLOSE_BRACKET {: System.out.println("function = read ( IDENTIFIER )"); :} |
                        WRITE OPEN_BRACKET write_args CLOSE_BRACKET {: System.out.println("function = write ( write_args )"); :}
                        ;

write_args          ::= IDENTIFIER {: System.out.println("write_args = IDENTIFIER"); :} |
                        STRING_CONSTANT {: System.out.println("write_args = STRING_CONSTANT"); :}
                        ;

reorder_function    ::=  REORDER_FUNCTION OPEN_BRACKET arguments CLOSE_BRACKET {: System.out.println("reorder_function = reorder ( arguments )"); :}
                        ;

arguments           ::= OPEN_SQUARE_BRACKET arguments_list CLOSE_SQUARE_BRACKET COMMA INTEGER_CONSTANT COMMA INTEGER_CONSTANT
                        {: System.out.println("arguments = [arguments_list], integer_constant, integer_constant"); :}
                        ;

arguments_list      ::= arguments_list COMMA expression {: System.out.println("arguments_list = arguments_list , expression"); :} |
                        expression {: System.out.println("arguments_list = expression"); :}
                        ;

negative_function   ::= NEGATIVE_CALCULATION_FUNCTION OPEN_BRACKET float_list CLOSE_BRACKET {: System.out.println("negative_function = negativeCalculation ( float_list )"); :}
                        ;

float_list          ::= float_element:f {: System.out.println("float_list =" + f); :} |
                        float_list COMMA float_element {: System.out.println("float_list , float_element"); :}
                        ;

float_element       ::= IDENTIFIER:id  {: RESULT = id; :} |
                        FLOAT_CONSTANT:f {: RESULT = f; :} |
                        SUB FLOAT_CONSTANT:f {: RESULT = f; :}
                        ;